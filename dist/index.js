!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("JsPriorityQueue",[],t):"object"==typeof exports?exports.JsPriorityQueue=t():e.JsPriorityQueue=t()}(self,(()=>(()=>{"use strict";var e={d:(t,s)=>{for(var i in s)e.o(s,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:s[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Heap:()=>s,SimpleMaxHeap:()=>i,SimpleMinHeap:()=>r});const s=class{get count(){return this.size}SENTRY;data=[];size=0;compare;selfCompare(e,t){return this.compare(e,t)}validInitParams(){if(void 0===this.SENTRY)throw"can not insert queue before the sentry been set ";if(void 0===this.compare)throw"can not insert queue before the compare callback been set "}constructor(...e){e.forEach(((e,t)=>{this.data[t+1]=e,this.size++})),this.buildHeap()}setSentry(e){this.SENTRY=e,this.data[0]=this.SENTRY}setCompare(e){this.compare=e}getMin(){if(0==this.size)throw"can not get element from an empty heap";return this.data[1]}isEmpty(){return 0===this.size}insertQueue(e){if(this.validInitParams(),this.selfCompare(this.SENTRY,e))throw`can not insert val bigger or smaller than ${this.SENTRY}`;this.size++;let t=this.size;for(;this.selfCompare(this.data[Math.floor(t/2)],e);)this.data[t]=this.data[Math.floor(t/2)],t=Math.floor(t/2);this.data[t]=e}deleteQueue(){if(this.isEmpty())throw"can not delete element from empty heap";let e=this.data[1],t=this.data[this.size--];return this.data[1]=t,this.data.length--,this.percDown(1),e}percDown(e){let t,s,i=this.data[e];for(t=e;2*t<=this.size&&(s=2*t,s!=this.size&&this.selfCompare(this.data[s+1],this.data[s])&&s++,!this.selfCompare(this.data[s],i));t=s)this.data[t]=this.data[s];this.data[t]=i}buildHeap(){for(let e=Math.floor(this.size/2);e>0;e--)this.percDown(e)}},i=class extends s{constructor(...e){super(...e),this.setSentry(1/0),this.setCompare(((e,t)=>e<=t))}deleteMax(){return this.deleteQueue()}},r=class extends s{constructor(...e){super(...e),this.setSentry(-1/0),this.setCompare(((e,t)=>e>=t))}deleteMin(){return this.deleteQueue()}};return t})()));
//# sourceMappingURL=index.js.map